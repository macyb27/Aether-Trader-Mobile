/**
 * Agent Orchestrator - Coordinates multi-agent trading workflow
 * 
 * Workflow: Hypothesis â†’ Backtest â†’ Paper Trade â†’ Validation â†’ Live
 * 
 * Agents:
 * 1. Rule Developer (RL) - Generates trading rules
 * 2. QA Bot - Validates rules and monitors risk
 * 3. Backtest Engine - Tests strategies on historical data
 * 4. Paper Trader - Tests strategies with live data (no real money)
 * 5. Market Intel - Provides news and sentiment data
 */

import { QABotAgent, RiskViolation } from "./qa-bot";
import { RLRuleDeveloperAgent, RLState, Experience } from "./rl-rule-developer";
import { TradingRule, StrategyDNA, Trade, Portfolio } from "../trading-store";

export type WorkflowPhase = 
  | "hypothesis" 
  | "backtest" 
  | "paper_trading" 
  | "validation" 
  | "live" 
  | "halted";

export type AgentType = 
  | "rule_developer" 
  | "qa_bot" 
  | "backtest_engine" 
  | "paper_trader" 
  | "market_intel";

export interface AgentMessage {
  from: AgentType;
  to: AgentType | "all";
  timestamp: Date;
  type: "request" | "response" | "alert" | "status";
  priority: "low" | "medium" | "high" | "critical";
  payload: any;
}

export interface WorkflowState {
  phase: WorkflowPhase;
  currentRule: TradingRule | null;
  currentStrategy: StrategyDNA | null;
  backtestResults: BacktestResults | null;
  paperTradingResults: PaperTradingResults | null;
  validationStatus: ValidationStatus;
  startedAt: Date;
  completedAt?: Date;
}

export interface BacktestResults {
  sharpeRatio: number;
  sortinoRatio: number;
  maxDrawdown: number;
  winRate: number;
  profitFactor: number;
  totalTrades: number;
  totalReturn: number;
  passed: boolean;
  reasons: string[];
}

export interface PaperTradingResults {
  totalTrades: number;
  winningTrades: number;
  losingTrades: number;
  winRate: number;
  sharpeRatio: number;
  maxDrawdown: number;
  totalReturn: number;
  daysTraded: number;
  passed: boolean;
  reasons: string[];
}

export interface ValidationStatus {
  approved: boolean;
  reasons: string[];
  riskScore: number;
  violations: RiskViolation[];
}

export class AgentOrchestrator {
  private qaBotAgent: QABotAgent;
  private rlRuleDeveloper: RLRuleDeveloperAgent;
  private workflowState: WorkflowState;
  private messageQueue: AgentMessage[] = [];
  private isRunning: boolean = false;
  
  constructor() {
    this.qaBotAgent = new QABotAgent();
    this.rlRuleDeveloper = new RLRuleDeveloperAgent();
    
    this.workflowState = {
      phase: "hypothesis",
      currentRule: null,
      currentStrategy: null,
      backtestResults: null,
      paperTradingResults: null,
      validationStatus: {
        approved: false,
        reasons: [],
        riskScore: 0,
        violations: [],
      },
      startedAt: new Date(),
    };
  }
  
  /**
   * Start autonomous trading workflow
   */
  async startWorkflow(): Promise<void> {
    if (this.isRunning) {
      throw new Error("Workflow is already running");
    }
    
    this.isRunning = true;
    this.workflowState.startedAt = new Date();
    
    try {
      // Phase 1: Generate hypothesis (trading rule)
      await this.runHypothesisPhase();
      
      // Phase 2: Backtest the rule
      await this.runBacktestPhase();
      
      // Phase 3: Paper trading (if backtest passed)
      if (this.workflowState.backtestResults?.passed) {
        await this.runPaperTradingPhase();
      }
      
      // Phase 4: Validation
      await this.runValidationPhase();
      
      // Phase 5: Go live (if validation passed)
      if (this.workflowState.validationStatus.approved) {
        await this.runLivePhase();
      }
      
      this.workflowState.completedAt = new Date();
    } catch (error) {
      this.sendMessage({
        from: "qa_bot",
        to: "all",
        timestamp: new Date(),
        type: "alert",
        priority: "critical",
        payload: {
          error: error instanceof Error ? error.message : "Unknown error",
          phase: this.workflowState.phase,
        },
      });
      
      this.workflowState.phase = "halted";
    } finally {
      this.isRunning = false;
    }
  }
  
  /**
   * Phase 1: Generate trading rule hypothesis using RL
   */
  private async runHypothesisPhase(): Promise<void> {
    this.workflowState.phase = "hypothesis";
    
    this.sendMessage({
      from: "rule_developer",
      to: "all",
      timestamp: new Date(),
      type: "status",
      priority: "medium",
      payload: { message: "Generating trading rule hypothesis..." },
    });
    
    // Generate rule using RL agent
    const rule = this.rlRuleDeveloper.generateRule(
      `RL-Generated Rule ${Date.now()}`,
      "Rule generated by Reinforcement Learning agent based on learned patterns"
    );
    
    this.workflowState.currentRule = rule;
    
    // QA Bot reviews the rule
    const reviewResult = this.qaBotAgent.reviewRuleCode(rule);
    
    if (!reviewResult.passed) {
      this.sendMessage({
        from: "qa_bot",
        to: "rule_developer",
        timestamp: new Date(),
        type: "alert",
        priority: "high",
        payload: {
          message: "Rule failed QA review",
          issues: reviewResult.issues,
          warnings: reviewResult.warnings,
        },
      });
      
      throw new Error(`Rule failed QA review: ${reviewResult.issues.join(", ")}`);
    }
    
    this.sendMessage({
      from: "qa_bot",
      to: "all",
      timestamp: new Date(),
      type: "status",
      priority: "medium",
      payload: {
        message: "Rule passed QA review",
        rule: rule.name,
        warnings: reviewResult.warnings,
      },
    });
  }
  
  /**
   * Phase 2: Backtest the rule on historical data
   */
  private async runBacktestPhase(): Promise<void> {
    this.workflowState.phase = "backtest";
    
    this.sendMessage({
      from: "backtest_engine",
      to: "all",
      timestamp: new Date(),
      type: "status",
      priority: "medium",
      payload: { message: "Running backtest on 2+ years of historical data..." },
    });
    
    // Simulate backtest results (in production, use real backtesting engine)
    const backtestResults: BacktestResults = {
      sharpeRatio: 1.2 + Math.random() * 0.8, // 1.2-2.0
      sortinoRatio: 1.5 + Math.random() * 0.8,
      maxDrawdown: 10 + Math.random() * 15, // 10-25%
      winRate: 0.45 + Math.random() * 0.2, // 45-65%
      profitFactor: 1.3 + Math.random() * 0.7, // 1.3-2.0
      totalTrades: 100 + Math.floor(Math.random() * 200), // 100-300
      totalReturn: 15 + Math.random() * 35, // 15-50%
      passed: false,
      reasons: [],
    };
    
    // Validate backtest results
    const validation = this.qaBotAgent.validateStrategyMetrics({
      sharpeRatio: backtestResults.sharpeRatio,
      maxDrawdown: backtestResults.maxDrawdown,
      winRate: backtestResults.winRate * 100,
      profitFactor: backtestResults.profitFactor,
    });
    
    backtestResults.passed = validation.approved;
    backtestResults.reasons = validation.reasons;
    
    this.workflowState.backtestResults = backtestResults;
    
    if (!backtestResults.passed) {
      this.sendMessage({
        from: "qa_bot",
        to: "all",
        timestamp: new Date(),
        type: "alert",
        priority: "high",
        payload: {
          message: "Backtest failed validation",
          reasons: backtestResults.reasons,
        },
      });
      
      throw new Error(`Backtest failed: ${backtestResults.reasons.join(", ")}`);
    }
    
    this.sendMessage({
      from: "backtest_engine",
      to: "all",
      timestamp: new Date(),
      type: "status",
      priority: "medium",
      payload: {
        message: "Backtest passed validation",
        sharpeRatio: backtestResults.sharpeRatio.toFixed(2),
        winRate: `${(backtestResults.winRate * 100).toFixed(1)}%`,
        maxDrawdown: `${backtestResults.maxDrawdown.toFixed(1)}%`,
      },
    });
  }
  
  /**
   * Phase 3: Paper trading with live data (minimum 50 trades, 14 days)
   */
  private async runPaperTradingPhase(): Promise<void> {
    this.workflowState.phase = "paper_trading";
    
    this.sendMessage({
      from: "paper_trader",
      to: "all",
      timestamp: new Date(),
      type: "status",
      priority: "medium",
      payload: { message: "Starting paper trading (min 50 trades, 14 days)..." },
    });
    
    // Simulate paper trading results (in production, use real paper trading)
    const paperTradingResults: PaperTradingResults = {
      totalTrades: 50 + Math.floor(Math.random() * 30), // 50-80
      winningTrades: 25 + Math.floor(Math.random() * 20), // 25-45
      losingTrades: 0,
      winRate: 0,
      sharpeRatio: 1.3 + Math.random() * 0.5, // 1.3-1.8
      maxDrawdown: 8 + Math.random() * 10, // 8-18%
      totalReturn: 10 + Math.random() * 20, // 10-30%
      daysTraded: 14 + Math.floor(Math.random() * 7), // 14-21
      passed: false,
      reasons: [],
    };
    
    paperTradingResults.losingTrades = paperTradingResults.totalTrades - paperTradingResults.winningTrades;
    paperTradingResults.winRate = paperTradingResults.winningTrades / paperTradingResults.totalTrades;
    
    // Validate paper trading results
    const validation = this.qaBotAgent.validateStrategyMetrics({
      sharpeRatio: paperTradingResults.sharpeRatio,
      maxDrawdown: paperTradingResults.maxDrawdown,
      winRate: paperTradingResults.winRate * 100,
    });
    
    // Check minimum requirements
    if (paperTradingResults.totalTrades < 50) {
      validation.reasons.push("Insufficient trades: minimum 50 required");
    }
    
    if (paperTradingResults.daysTraded < 14) {
      validation.reasons.push("Insufficient trading days: minimum 14 required");
    }
    
    paperTradingResults.passed = validation.approved && validation.reasons.length === 0;
    paperTradingResults.reasons = validation.reasons;
    
    this.workflowState.paperTradingResults = paperTradingResults;
    
    if (!paperTradingResults.passed) {
      this.sendMessage({
        from: "qa_bot",
        to: "all",
        timestamp: new Date(),
        type: "alert",
        priority: "high",
        payload: {
          message: "Paper trading failed validation",
          reasons: paperTradingResults.reasons,
        },
      });
      
      throw new Error(`Paper trading failed: ${paperTradingResults.reasons.join(", ")}`);
    }
    
    this.sendMessage({
      from: "paper_trader",
      to: "all",
      timestamp: new Date(),
      type: "status",
      priority: "medium",
      payload: {
        message: "Paper trading passed validation",
        totalTrades: paperTradingResults.totalTrades,
        winRate: `${(paperTradingResults.winRate * 100).toFixed(1)}%`,
        sharpeRatio: paperTradingResults.sharpeRatio.toFixed(2),
      },
    });
  }
  
  /**
   * Phase 4: Final validation by QA Bot
   */
  private async runValidationPhase(): Promise<void> {
    this.workflowState.phase = "validation";
    
    this.sendMessage({
      from: "qa_bot",
      to: "all",
      timestamp: new Date(),
      type: "status",
      priority: "high",
      payload: { message: "Running final validation..." },
    });
    
    const reasons: string[] = [];
    const violations = this.qaBotAgent.getViolations();
    const riskReport = this.qaBotAgent.generateRiskReport();
    
    // Check if all phases passed
    if (!this.workflowState.backtestResults?.passed) {
      reasons.push("Backtest did not pass validation");
    }
    
    if (!this.workflowState.paperTradingResults?.passed) {
      reasons.push("Paper trading did not pass validation");
    }
    
    // Check risk score
    if (riskReport.riskScore > 50) {
      reasons.push(`Risk score too high: ${riskReport.riskScore}/100`);
    }
    
    // Check critical violations
    if (riskReport.criticalViolations > 0) {
      reasons.push(`${riskReport.criticalViolations} critical risk violations detected`);
    }
    
    this.workflowState.validationStatus = {
      approved: reasons.length === 0,
      reasons,
      riskScore: riskReport.riskScore,
      violations,
    };
    
    if (!this.workflowState.validationStatus.approved) {
      this.sendMessage({
        from: "qa_bot",
        to: "all",
        timestamp: new Date(),
        type: "alert",
        priority: "critical",
        payload: {
          message: "Final validation failed",
          reasons,
          riskScore: riskReport.riskScore,
        },
      });
      
      throw new Error(`Validation failed: ${reasons.join(", ")}`);
    }
    
    this.sendMessage({
      from: "qa_bot",
      to: "all",
      timestamp: new Date(),
      type: "status",
      priority: "high",
      payload: {
        message: "Final validation passed - APPROVED FOR LIVE TRADING",
        riskScore: riskReport.riskScore,
      },
    });
  }
  
  /**
   * Phase 5: Activate rule for live trading
   */
  private async runLivePhase(): Promise<void> {
    this.workflowState.phase = "live";
    
    this.sendMessage({
      from: "paper_trader",
      to: "all",
      timestamp: new Date(),
      type: "status",
      priority: "critical",
      payload: {
        message: "ðŸš€ GOING LIVE - Rule activated for real trading",
        rule: this.workflowState.currentRule?.name,
      },
    });
    
    // In production: Activate rule for live trading
    // For now, just log the success
  }
  
  /**
   * Emergency halt - stop all trading immediately
   */
  emergencyHalt(reason: string): void {
    this.workflowState.phase = "halted";
    this.isRunning = false;
    
    this.sendMessage({
      from: "qa_bot",
      to: "all",
      timestamp: new Date(),
      type: "alert",
      priority: "critical",
      payload: {
        message: "ðŸ›‘ EMERGENCY HALT - All trading stopped",
        reason,
      },
    });
  }
  
  /**
   * Send message to agent(s)
   */
  private sendMessage(message: AgentMessage): void {
    this.messageQueue.push(message);
    
    // In production: Implement proper message routing and handling
    console.log(`[${message.priority.toUpperCase()}] ${message.from} â†’ ${message.to}:`, message.payload);
  }
  
  /**
   * Get workflow state
   */
  getWorkflowState(): WorkflowState {
    return { ...this.workflowState };
  }
  
  /**
   * Get message queue
   */
  getMessages(limit?: number): AgentMessage[] {
    if (limit) {
      return this.messageQueue.slice(-limit);
    }
    return [...this.messageQueue];
  }
  
  /**
   * Clear message queue
   */
  clearMessages(): void {
    this.messageQueue = [];
  }
  
  /**
   * Get QA Bot agent
   */
  getQABot(): QABotAgent {
    return this.qaBotAgent;
  }
  
  /**
   * Get RL Rule Developer agent
   */
  getRLRuleDeveloper(): RLRuleDeveloperAgent {
    return this.rlRuleDeveloper;
  }
}
